<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    

    <title>How to query-replace multiple matches! – Tony Zorman</title>
    <!-- https://purecss.io/ -->
    <link rel="stylesheet" href="../../css/pure-min.css" />
    <link rel="stylesheet" type="text/css" href="../../css/skin.css" />
    <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
    
  </head>

  <body class="pure-skin-solid">
    <div class="pure-g-r">
      <div class="pure-u-1-4">
        <div id="navigation" class="no-print">
          <div class="pure-menu pure-menu-open">
            <a href="../../" class="pure-menu-heading menu-title">
              Blog<br>
              <span class="menu-subtitle">Tony Zorman</span>
            </a>
            <ul>
              <li><a href="../../posts.html">Posts</a></li>
              <li><a href="../../research.html">Research</a></li>
              <li><a href="../../free-software.html">FLOSS</a></li>
              <li><a href="../../about.html">About</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="pure-u-3-4">
        <div id="content">
          <h1>How to query-replace multiple matches!</h1>

          <article>
    <section class="header">
      Posted on 2022-08-06
      
        | <a title="All pages tagged 'emacs'." href="../../tags/emacs.html">emacs</a>
      
    </section>
    <section>
        <div id="contents">
<p class="mini-header">Contents</p>
<ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#the-solution">The Solution</a>
<ul>
<li><a href="#the-code">The Code</a></li>
</ul></li>
</ul>
</div>
<p>As its name suggests, Emacs’s <code>query-replace</code> function (bound to <code>M-%</code>
by default) can be used to replace occurences of one string with
another. In comparison to other tools that are used for similar
purposes—(a subset of) keyboard macros and multiple-cursors—the whole
process after entering the <code>from</code> and <code>to</code> strings is interactive all
the way through: it’s very fast to step through the individual matches
and decide on the spot whether one would like to replace them or not.
Needless to say, I like <code>query-replace</code> a lot! In true Emacs fashion,
the function also takes way too many arguments: among other things, it
can operate on the current region, backwards, or only on things
surrounded by words boundaries.</p>
<p>However, there is one crucial feature missing from its default
functionality: the ability to create multiple <code>from → to</code> pairs. But
this is Emacs, after all, which means that I can just write that
<code>query-replace-many</code> function I’ve always wanted!</p>
<!--more-->
<h1 id="motivation">Motivation</h1>
<p>Originally, my motivation came through <a href="../../research.html">work</a>, where I <a href="../phd-workflow/2022-05-01-my-phd-workflow.html">write a lot of
LaTeX</a>. When polishing papers, it sometimes happens that I would like
to change or unify the notation of certain objects in the current
equation/environment/file.</p>
<p>When an alteration like this only encompasses a single action, like
switching <code>T</code> to <code>H</code>, a simple <code>query-replace</code> after narrowing to the
current region of interest is totally sufficient. For others, like
changing <code>T</code> to <code>H</code> <em>and</em> <code>S</code> to <code>G</code>, this solution, along with
multiple-cursors and other tools people usually go for, would already be
unsatisfactory—the whole region would need to be traversed twice. Now
imagine that you want to change <code>T</code> to <code>U</code> <em>and</em> <code>U</code> to <code>T</code>: chaos!
Save having to give some sort of temporary name to one of the objects,
which would be even slower, <code>query-replace</code> is quite useless in this
situation. It’s possible to cook up a manual solution using the
alternative <code>query-replace-regexp</code> function and capture groups, but I’m
unsure how many people know their elisp regular expressions well enough
for that to be time efficient. I don’t, and almost certainly never
will, so it seemed much easier to automate this instead!</p>
<h1 id="the-solution">The Solution</h1>
<p>Thankfully, since <code>replace.el</code> sports a decent API, writing a version of
<code>query-replace</code> that accepts multiple arguments turns out to be easy
enough. The high-level overview is this: we read in multiple queries
until an empty input is given<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, build up a regular expression of the
form <code>"\\(?:query-1\\|query-2\\|…\\)"</code>, and—when it comes to
replacing—test the current thing to be replaced against all of the
queries to select the correct one.</p>
<p>The beauty of this is that, since it’s really just a thin wrapper over
two functions from <code>replace.el</code> that do the heavy lifting, all of the
modules regular functionality, like the keybindings and history, just
work.</p>
<p>For example, in the following I replace <code>T</code> with <code>U</code> and, at the same
time, <code>U</code> with <code>T</code>. The first few matches are stepped through and the
rest is just accepted wholesale. At the bottom, you can see the default
<code>query-replace</code> interface when interacting with the query.</p>
<p><img class="pure-img" src="./query-replace-many.gif"></p>
<p>The only cosmetic imperfection of this is that, while the replacement
candidate itself is correctly updated, we see the whole regular
expression <code>\(?U:\|T\)</code> as the thing to be replaced instead of the bit
that’s actually matching currently. However, since this would seem to
require some work and one of course sees what’s to be replaced by
looking at the thing at point, I can very much live with this for the
moment.</p>
<h2 id="the-code">The Code</h2>
<p>Below is the full source code, in all of its hacky glory. Note that you
will need to <code>require</code> the <code>s.el</code> and <code>dash.el</code> libraries for this to
work, if you haven’t loaded these already (if you use any amount of
packages at all, chances are that you have).</p>
<!-- pandoc does not support emacs-lisp :< -->
<div class="sourceCode" id="cb1"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">defun</span><span class="fu"> slot/get-queries </span>(&amp;optional pairs)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Get multiple `query-replace' pairs from the user.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">PAIRS is a list of replacement pairs of the form (FROM . TO).&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  (-let* (((from to delim arg)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>           (query-replace-read-args</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            (s-join <span class="st">&quot; &quot;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                    (-non-nil</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">list</span> <span class="st">&quot;Query replace many&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                           (<span class="kw">cond</span> ((<span class="kw">eq</span> current-prefix-arg '-) <span class="st">&quot;backward&quot;</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                                 (current-prefix-arg         <span class="st">&quot;word&quot;</span>))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                           (<span class="kw">when</span> (use-region-p) <span class="st">&quot;in region&quot;</span>))))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">nil</span>))                       <span class="co">; no regexp-flag</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>          (from-to (<span class="kw">cons</span> (regexp-quote from)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                         (s-replace <span class="st">&quot;</span><span class="sc">\\</span><span class="st">&quot;</span> <span class="st">&quot;</span><span class="sc">\\\\</span><span class="st">&quot;</span> to))))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; </span><span class="al">HACK</span><span class="co">: Since the default suggestion of replace.el will be</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; the last one we've entered, an empty string will give us</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; exactly that.  Instead of trying to fight against this,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; use it in order to signal an exit.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (-contains? pairs from-to)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">list</span> pairs delim arg)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      (slot/get-queries (<span class="kw">push</span> from-to pairs)))))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>(<span class="kw">defun</span><span class="fu"> slot/query-replace-many</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    (pairs &amp;optional delimited start end backward region-noncontiguous-p)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Like `query-replace', but query for several replacements.</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="st">Query for replacement pairs until the users enters an empty</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="st">string (but see `slot/get-queries').</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="st">Refer to `query-replace' and `perform-replace' for what the other</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="st">arguments actually mean.&quot;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  (interactive</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">let</span> ((common (slot/get-queries)))</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">list</span> (<span class="kw">nth</span> <span class="dv">0</span> common) (<span class="kw">nth</span> <span class="dv">1</span> common)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">if</span> (use-region-p) (region-beginning))</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">if</span> (use-region-p) (region-end))</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">nth</span> <span class="dv">2</span> common)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">if</span> (use-region-p) (region-noncontiguous-p)))))</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  (perform-replace</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>   (concat <span class="st">&quot;</span><span class="sc">\\</span><span class="st">(?:&quot;</span> (mapconcat #'car pairs <span class="st">&quot;</span><span class="sc">\\</span><span class="st">|&quot;</span>) <span class="st">&quot;</span><span class="sc">\\</span><span class="st">)&quot;</span>) <span class="co">; build query</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">cons</span> (<span class="kw">lambda</span> (pairs _count)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>           (cl-loop for (from . to) in pairs</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">when</span> (string-match from (match-string <span class="dv">0</span>))</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> to))</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>         pairs)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>   :query :regexp</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>   delimited <span class="kw">nil</span> <span class="kw">nil</span> start end backward region-noncontiguous-p))</span></code></pre></div>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This isn’t <em>quite</em> what’s actually done, but it’s the right mental
model to have (since this is how the function behaves). The gory
details are that we use the fact that <code>replace.el</code>’s default
suggestion is always the last query that was entered by the user.
What happens on an empty input is quite deep in the bowels of
<code>query-replace-read-from</code>. Since replacing these massive internal
functions sounds like a real pain, leaning on that functionality
suddenly appears much more reasonable. Thus, when we get back a
query that has already been entered in one way or another, we bail
out.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>


        </div>
        <div id="footer" class="no-print">
          <a href="../../atom.xml">RSS</a>
          &nbsp;|&nbsp;
          <a href="https://github.com/slotThe/slotThe.github.io">Website source</a>
          &nbsp;|&nbsp;
          <a href="../../impressum.html">Legal notice and privacy policy</a>
        </div>
      </div>
    </div>
  </body>
</html>
